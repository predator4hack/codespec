### Phase 2: File Management System (Days 4-6)

#### 2.1 Template Service

```typescript
// src/services/templateService.ts
export class TemplateService {
    async getDefaultTemplate(): Promise<string>;
    async createCustomTemplate(templatePath: string): Promise<void>;
    async populateTemplate(templateData: FeatureSpecData): Promise<string>;
}
```

#### 2.2 File Service

```typescript
// src/services/fileService.ts
export class FileService {
    async ensureFeaturesDirectory(): Promise<void>;
    async createFeatureFile(name: string, content: string): Promise<void>;
    async readFeatureFile(path: string): Promise<string>;
    async updateFeatureFile(path: string, content: string): Promise<void>;
    async listFeatureFiles(): Promise<string[]>;
}
```

#### 2.3 Feature Creation Workflow

-   [ ] Implement "Create New Feature" command
-   [ ] Create `.features/` directory if it doesn't exist
-   [ ] Generate feature file from template
-   [ ] Open created file in editor

Clarifying Questions

Before implementing Phase 2, I need clarification on:

1. Template Location: Should the default template be embedded in the code or
   stored as a separate file? The README shows it in
   src/templates/defaultFeature.md but this file doesn't exist yet.
   create and store it in separate file

2. Feature File Format: Should feature files be:

-   Named with .md extension (e.g., my-feature.md)?

3. Directory Structure: Should .features/ be created in:

-   The workspace root

4. Template Data: What data should be passed to populateTemplate()? The
   FeatureSpecData interface isn't defined yet.
   Do whatever you think is best

5. Error Handling: How should we handle:

-   Permission errors when creating directories/files? ask for permission
-   Duplicate feature names? Not allow same feature name
-   Invalid file names? not allow to create such name

6. Integration: Should this phase integrate with the existing tree view to
   show actual feature files instead of dummy data?
   Yes

## Detailed Implementation Plan for Phase 2

### Implementation Overview

This phase implements the file management system that allows users to create, read, and manage feature specification files. The system will create `.features/` directories in workspace roots, use markdown templates, and integrate with the existing tree view.

### Prerequisites

-   Phase 1 must be completed (basic extension structure, tree provider, commands)
-   VS Code workspace must be open
-   User must have write permissions to workspace directory

### Implementation Tasks

#### Task 2.1: Create Default Template File

**Objective**: Create a reusable markdown template for feature specifications.

**File to create**: `src/templates/defaultFeature.md`

**Template content requirements**:

-   Feature name placeholder: `{featureName}`
-   Creation date placeholder: `{createdDate}`
-   Last updated placeholder: `{lastUpdated}`
-   Status placeholder: `{status}` (default: "Draft")
-   CLI Agent placeholder: `{cliAgent}` (default: "Not Set")
-   Structured sections for: Description, Acceptance Criteria, Important Files, Context, Technical Considerations
-   Reserved sections for AI-generated content: Clarifying Questions, Implementation Plan, Metadata

**Template structure**:

```markdown
# Feature Specification: {featureName}

**Created:** {createdDate}
**Last Updated:** {lastUpdated}
**Status:** {status}
**CLI Agent:** {cliAgent}

## Description

[Clear description of the feature and problem it solves]

## Acceptance Criteria

-   [ ] [Measurable success criteria]
-   [ ] [Include edge cases and error scenarios]

## Important Files to Analyze

<!-- List relevant files for implementation -->

-   `src/example.ts` - [Brief description of relevance]

## Additional Context

[Additional information, constraints, dependencies]

## Technical Considerations

[Technical constraints, performance requirements, architectural decisions]

---

<!-- DO NOT EDIT BELOW - AI-generated content -->

## Clarifying Questions

<!-- Generated by CLI agents -->

## Implementation Plan

<!-- Generated by CLI agents -->

## Metadata

-   **Created:** {createdDate}
-   **Last Updated:** {lastUpdated}
-   **CLI Agent Used:** {cliAgent}
-   **Questions Generated:** [timestamp]
-   **Plan Generated:** [timestamp]
```

#### Task 2.2: Define Data Models

**Objective**: Define TypeScript interfaces for feature specification data.

**File to update**: `src/models/featureSpec.ts`

**Interfaces to define**:

```typescript
export interface FeatureSpecData {
    featureName: string;
    createdDate: string;
    lastUpdated: string;
    status: "Draft" | "In Progress" | "Ready for Review" | "Completed";
    cliAgent: "claude-code" | "gemini-cli" | "Not Set";
    description?: string;
    acceptanceCriteria?: string[];
    importantFiles?: string[];
    additionalContext?: string;
    technicalConsiderations?: string;
}

export interface FeatureSpecItem {
    name: string;
    path: string;
    type: "feature" | "directory";
    children?: FeatureSpecItem[];
}

export interface FeatureSpecMetadata {
    created: string;
    lastUpdated: string;
    cliAgentUsed: string;
    questionsGenerated?: string;
    planGenerated?: string;
}
```

#### Task 2.3: Implement Template Service

**Objective**: Create service for template management and population.

**File to create**: `src/services/templateService.ts`

**Implementation requirements**:

1. **Template Loading**:

    - Read default template from `src/templates/defaultFeature.md`
    - Handle file read errors gracefully
    - Cache template content for performance

2. **Template Population**:

    - Replace all placeholders with actual data
    - Handle missing data gracefully with sensible defaults
    - Generate current timestamps for date fields
    - Sanitize user input to prevent markdown injection

3. **Custom Template Support**:
    - Allow users to specify custom template paths
    - Validate custom templates have required placeholders
    - Fall back to default template if custom template fails

**Key methods**:

```typescript
export class TemplateService {
    private templateCache: Map<string, string> = new Map();

    async getDefaultTemplate(): Promise<string>;
    async createCustomTemplate(templatePath: string): Promise<void>;
    async populateTemplate(templateData: FeatureSpecData): Promise<string>;
    private async loadTemplate(templatePath: string): Promise<string>;
    private validateTemplate(content: string): boolean;
    private sanitizeInput(input: string): string;
    private formatDate(date: Date): string;
}
```

**Error handling**:

-   Template file not found: Use embedded fallback template
-   Permission errors: Show user-friendly error message
-   Invalid template: Show validation errors and use default

#### Task 2.4: Implement File Service

**Objective**: Create service for file system operations on feature specs.

**File to create**: `src/services/fileService.ts`

**Implementation requirements**:

1. **Directory Management**:

    - Create `.features/` directory in workspace root
    - Handle multiple workspace folders
    - Check and request permissions if needed
    - Create subdirectories if specified

2. **File Operations**:

    - Create feature files with `.md` extension
    - Read existing feature files
    - Update feature files while preserving structure
    - List all feature files recursively
    - Validate file names (no special characters, proper extensions)

3. **Name Validation**:

    - Convert spaces to hyphens
    - Remove or replace invalid characters
    - Ensure unique names (check existing files)
    - Validate length limits

4. **Path Resolution**:
    - Handle relative and absolute paths
    - Resolve workspace-relative paths
    - Support multiple workspace folders

**Key methods**:

```typescript
export class FileService {
    private workspaceRoot: string;

    constructor();
    async ensureFeaturesDirectory(): Promise<void>;
    async createFeatureFile(name: string, content: string): Promise<string>;
    async readFeatureFile(path: string): Promise<string>;
    async updateFeatureFile(path: string, content: string): Promise<void>;
    async listFeatureFiles(): Promise<string[]>;
    async deleteFeatureFile(path: string): Promise<void>;
    async featureExists(name: string): Promise<boolean>;
    private validateFileName(name: string): {
        valid: boolean;
        sanitized: string;
        error?: string;
    };
    private getWorkspaceRoot(): string;
    private getFeaturesPath(): string;
    private generateUniqueFileName(baseName: string): Promise<string>;
}
```

**Error handling**:

-   Permission errors: Show permission request dialog
-   Duplicate names: Suggest alternative names or append numbers
-   Invalid names: Show validation errors and suggestions
-   File system errors: Show user-friendly error messages
-   Missing workspace: Show error and guidance

#### Task 2.5: Update Tree Provider

**Objective**: Integrate file service with tree view to show actual feature files.

**File to update**: `src/providers/featureTreeProvider.ts`

**Implementation requirements**:

1. **File-based Tree Structure**:

    - Replace dummy data with actual feature files
    - Show `.features/` directory structure
    - Support nested directories
    - Show file icons and context information

2. **Tree Item Types**:

    - Directory items (expandable)
    - Feature file items (clickable)
    - Metadata display (creation date, status)

3. **Refresh Mechanism**:

    - Watch file system changes
    - Refresh tree when files are added/removed/modified
    - Handle file system errors gracefully

4. **Context Menus**:
    - Different menus for files vs directories
    - Add actions like "Open", "Delete", "Rename"

**Key updates**:

```typescript
export class FeatureTreeProvider
    implements vscode.TreeDataProvider<FeatureSpecItem>
{
    private _onDidChangeTreeData: vscode.EventEmitter<
        FeatureSpecItem | undefined | null | void
    >;
    private fileService: FileService;
    private fileWatcher: vscode.FileSystemWatcher;

    constructor();
    getTreeItem(element: FeatureSpecItem): vscode.TreeItem;
    getChildren(element?: FeatureSpecItem): Promise<FeatureSpecItem[]>;
    refresh(): void;
    private buildTreeStructure(files: string[]): FeatureSpecItem[];
    private createTreeItem(item: FeatureSpecItem): vscode.TreeItem;
    private watchFiles(): void;
}
```

#### Task 2.6: Update Create New Feature Command

**Objective**: Integrate template and file services into the feature creation workflow.

**File to update**: `src/extension.ts`

**Implementation requirements**:

1. **Enhanced User Input**:

    - Feature name validation during input
    - Real-time feedback on name validity
    - Preview of generated file name

2. **File Creation Workflow**:

    - Validate and sanitize feature name
    - Check for existing features with same name
    - Create `.features/` directory if needed
    - Generate feature file from template
    - Open created file in editor
    - Refresh tree view

3. **Error Handling**:
    - Handle all file system errors
    - Show progress indicators for long operations
    - Provide actionable error messages
    - Allow retry on failure

**Updated command implementation**:

```typescript
async function createNewFeature() {
    try {
        // Step 1: Get and validate feature name
        const featureName = await getValidFeatureName();
        if (!featureName) return;

        // Step 2: Check for duplicates
        const exists = await fileService.featureExists(featureName);
        if (exists) {
            const action = await handleDuplicateName(featureName);
            if (!action) return;
        }

        // Step 3: Create feature with progress indicator
        await vscode.window.withProgress(
            {
                location: vscode.ProgressLocation.Notification,
                title: "Creating feature specification...",
                cancellable: false,
            },
            async (progress) => {
                // Create .features directory
                progress.report({
                    increment: 25,
                    message: "Creating directory...",
                });
                await fileService.ensureFeaturesDirectory();

                // Generate content from template
                progress.report({
                    increment: 25,
                    message: "Generating content...",
                });
                const templateData: FeatureSpecData = {
                    featureName,
                    createdDate: new Date().toISOString().split("T")[0],
                    lastUpdated: new Date().toISOString().split("T")[0],
                    status: "Draft",
                    cliAgent: "Not Set",
                };
                const content = await templateService.populateTemplate(
                    templateData
                );

                // Create file
                progress.report({ increment: 25, message: "Creating file..." });
                const filePath = await fileService.createFeatureFile(
                    featureName,
                    content
                );

                // Open in editor
                progress.report({
                    increment: 25,
                    message: "Opening editor...",
                });
                const document = await vscode.workspace.openTextDocument(
                    filePath
                );
                await vscode.window.showTextDocument(document);

                // Refresh tree
                treeProvider.refresh();
            }
        );

        vscode.window.showInformationMessage(
            `Feature "${featureName}" created successfully!`
        );
    } catch (error) {
        errorHandler.handleFeatureCreationError(error);
    }
}

async function getValidFeatureName(): Promise<string | undefined> {
    return await vscode.window.showInputBox({
        prompt: "Enter feature name",
        placeHolder: "my-awesome-feature",
        validateInput: (value) => {
            const validation = fileService.validateFileName(value);
            return validation.valid ? undefined : validation.error;
        },
    });
}
```

### Integration Points

#### Service Dependencies

```typescript
// In extension.ts
let templateService: TemplateService;
let fileService: FileService;
let treeProvider: FeatureTreeProvider;

export async function activate(context: vscode.ExtensionContext) {
    // Initialize services in order
    templateService = new TemplateService();
    fileService = new FileService();
    treeProvider = new FeatureTreeProvider(fileService);

    // Register services with context for cleanup
    context.subscriptions.push(templateService, fileService, treeProvider);
}
```

#### Error Handling Strategy

```typescript
// src/utils/errorHandler.ts (to be created)
export class ErrorHandler {
    static handleFileSystemError(error: Error, operation: string): void;
    static handlePermissionError(path: string): Promise<boolean>;
    static handleValidationError(field: string, error: string): void;
    static showRetryDialog(operation: string): Promise<boolean>;
}
```

### Testing Strategy

#### Manual Testing Checklist

1. **Template Service**:

    - [ ] Default template loads correctly
    - [ ] Template placeholders are replaced properly
    - [ ] Invalid template paths handled gracefully
    - [ ] Custom templates work

2. **File Service**:

    - [ ] `.features/` directory created in workspace root
    - [ ] Feature files created with correct names and content
    - [ ] Duplicate names handled properly
    - [ ] Invalid names rejected with helpful messages
    - [ ] File reading/writing works correctly

3. **Tree Integration**:

    - [ ] Tree shows actual feature files
    - [ ] Tree refreshes when files change
    - [ ] File icons and metadata display correctly
    - [ ] Context menus work

4. **Feature Creation**:
    - [ ] Complete workflow works end-to-end
    - [ ] Progress indicators show during creation
    - [ ] Created files open in editor
    - [ ] Error cases handled gracefully

#### Error Scenarios to Test

-   No workspace open
-   Read-only workspace
-   Permission denied
-   Disk full
-   Invalid file names
-   Duplicate feature names
-   Template file missing
-   Corrupted template file

### File Structure After Implementation

```
src/
├── extension.ts                    # Updated with service integration
├── models/
│   └── featureSpec.ts             # Enhanced with new interfaces
├── providers/
│   └── featureTreeProvider.ts     # Updated for file-based tree
├── services/
│   ├── templateService.ts         # New: Template management
│   └── fileService.ts             # New: File operations
├── templates/
│   └── defaultFeature.md          # New: Default template
└── utils/
    └── errorHandler.ts             # New: Error handling utilities
```

### Success Criteria

After Phase 2 implementation:

1. **Template System Works**:

    - Default template exists and loads
    - Template placeholders populate correctly
    - Custom templates supported

2. **File Management Works**:

    - `.features/` directory auto-created
    - Feature files created with correct content
    - File names validated and sanitized
    - Duplicate names prevented

3. **Tree Integration Works**:

    - Tree shows actual feature files
    - File operations reflected in tree
    - Context menus functional

4. **User Experience**:

    - Feature creation workflow smooth
    - Clear error messages shown
    - Progress indicators for long operations
    - Files open automatically in editor

5. **Error Handling**:
    - All error scenarios handled gracefully
    - User gets actionable feedback
    - System recovers from errors appropriately

### Dependencies for Next Phase

This implementation prepares for Phase 3 (CLI Integration) by:

-   Providing file paths for CLI agent communication
-   Establishing feature spec format for AI processing
-   Creating infrastructure for metadata tracking
-   Setting up foundation for AI-generated content integration

The file management system forms the core foundation that all subsequent phases will build upon.
