import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { FeatureSpecData } from '../models/featureSpec';

export class TemplateService {
    private templateCache: Map<string, string> = new Map();
    private readonly defaultTemplatePath: string;

    constructor(private context: vscode.ExtensionContext) {
        this.defaultTemplatePath = path.join(context.extensionPath, 'src', 'templates', 'defaultFeature.md');
    }

    async getDefaultTemplate(): Promise<string> {
        return await this.loadTemplate(this.defaultTemplatePath);
    }

    async createCustomTemplate(templatePath: string): Promise<void> {
        try {
            const defaultTemplate = await this.getDefaultTemplate();
            await fs.promises.writeFile(templatePath, defaultTemplate, 'utf8');
        } catch (error) {
            throw new Error(`Failed to create custom template: ${error}`);
        }
    }

    async populateTemplate(templateData: FeatureSpecData): Promise<string> {
        try {
            const template = await this.getDefaultTemplate();
            return this.replaceTemplateVariables(template, templateData);
        } catch (error) {
            // Fall back to embedded template if file loading fails
            const fallbackTemplate = this.getEmbeddedTemplate();
            return this.replaceTemplateVariables(fallbackTemplate, templateData);
        }
    }

    private async loadTemplate(templatePath: string): Promise<string> {
        // Check cache first
        if (this.templateCache.has(templatePath)) {
            return this.templateCache.get(templatePath)!;
        }

        try {
            const content = await fs.promises.readFile(templatePath, 'utf8');
            if (!this.validateTemplate(content)) {
                throw new Error('Template validation failed');
            }
            
            // Cache the template
            this.templateCache.set(templatePath, content);
            return content;
        } catch (error) {
            throw new Error(`Failed to load template from ${templatePath}: ${error}`);
        }
    }

    private validateTemplate(content: string): boolean {
        const requiredPlaceholders = [
            '{featureName}',
            '{createdDate}',
            '{lastUpdated}',
            '{status}',
            '{cliAgent}'
        ];

        return requiredPlaceholders.every(placeholder => content.includes(placeholder));
    }

    private sanitizeInput(input: string): string {
        // Remove potential markdown injection patterns
        return input
            .replace(/[<>]/g, '') // Remove HTML-like tags
            .replace(/\[([^\]]*)\]\([^)]*\)/g, '$1') // Remove markdown links
            .replace(/`+/g, '') // Remove code blocks
            .trim();
    }

    private formatDate(date: Date): string {
        return date.toISOString().split('T')[0];
    }

    private replaceTemplateVariables(template: string, data: FeatureSpecData): string {
        let result = template;

        // Replace basic placeholders
        result = result.replace(/{featureName}/g, this.sanitizeInput(data.featureName));
        result = result.replace(/{createdDate}/g, data.createdDate);
        result = result.replace(/{lastUpdated}/g, data.lastUpdated);
        result = result.replace(/{status}/g, data.status);
        result = result.replace(/{cliAgent}/g, data.cliAgent);

        // Replace optional fields if provided
        if (data.description) {
            result = result.replace('[Provide a clear, concise description of the feature. What problem does it solve? Who is the target user?]', this.sanitizeInput(data.description));
        }

        return result;
    }

    private getEmbeddedTemplate(): string {
        // Fallback template embedded in code
        return `# Feature Specification: {featureName}

**Created:** {createdDate}  
**Last Updated:** {lastUpdated}  
**Status:** {status}  
**CLI Agent:** {cliAgent}

## Description

[Provide a clear, concise description of the feature. What problem does it solve? Who is the target user?]

## Acceptance Criteria

- [ ] [Define what success looks like for this feature]
- [ ] [Include measurable outcomes where possible]
- [ ] [Consider edge cases and error scenarios]

## Important Files to Analyze

<!-- List files that are relevant to this feature implementation -->

- \`src/components/example.tsx\` - [Brief description of why this file is important]
- \`src/utils/helper.ts\` - [Context about this file's relevance]

## Additional Context

[Any additional information, constraints, dependencies, or requirements]

## Technical Considerations

[Any technical constraints, performance requirements, or architectural decisions]

---

<!-- DO NOT EDIT BELOW THIS LINE - Content will be generated by AI -->

## Clarifying Questions

<!-- Questions will be generated and appended here -->

## Implementation Plan

<!-- Implementation plan will be generated and appended here -->

## Metadata

- **Created:** {createdDate}
- **Last Updated:** {lastUpdated}
- **CLI Agent Used:** {cliAgent}
- **Questions Generated:** [timestamp]
- **Plan Generated:** [timestamp]`;
    }

    dispose(): void {
        this.templateCache.clear();
    }
}